#!/usr/bin/env node
/**
 * FORGE Framework - AI-driven development through natural conversation
 * Created by Scott Feltham - https://github.com/scottfeltham/forge-framework
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const [,, cmd, ...args] = process.argv;

// Helpers
const log = console.log;
const tpl = n => fs.readFileSync(path.join(__dirname, 'templates', n), 'utf8');
const write = (p, c) => fs.writeFileSync(p, c);
const exists = p => fs.existsSync(p);
const timestamp = () => new Date().toISOString().replace(/[:.]/g, '-');

// Ensure .forge exists
if (!exists('.forge')) fs.mkdirSync('.forge/history', { recursive: true });

const commands = {
  init() {
    if (exists('forge.yaml')) return log('‚ö†Ô∏è  Already initialized');
    write('forge.yaml', `# FORGE Configuration
project: ${path.basename(process.cwd())}
mode: conversational
ai: {primary: claude, model: sonnet}`);
    write('.forge/INIT_ANALYSIS.md', tpl('init-prompt.md'));
    log('üî® FORGE initialized!\n\nü§ñ Claude will analyze your project...');
  },

  new(name) {
    if (!name) return log('Usage: forge new <feature>');
    const cycle = tpl('cycle.md')
      .replace(/{{FEATURE}}/g, name)
      .replace(/{{DATE}}/g, new Date().toISOString().split('T')[0]);
    
    const isTeam = exists('forge.yaml') && 
      fs.readFileSync('forge.yaml', 'utf8').includes('collaborative');
    
    if (isTeam) {
      const dir = '.forge/current';
      if (!exists(dir)) fs.mkdirSync(dir, { recursive: true });
      const file = `${name.toLowerCase().replace(/\s+/g, '-')}.md`;
      write(`${dir}/${file}`, cycle);
      log(`‚ú® Started: ${name}\nüìÅ Created: ${dir}/${file}`);
    } else {
      write('.forge/current.md', cycle);
      log(`‚ú® Started: ${name}\nüìã Phase: Focus\nü§ñ Claude will guide you`);
    }
  },

  status() {
    const current = '.forge/current.md';
    if (exists(current)) {
      log(fs.readFileSync(current, 'utf8'));
    } else if (exists('.forge/current')) {
      const cycles = fs.readdirSync('.forge/current').filter(f => f.endsWith('.md'));
      log(cycles.length ? `üìä Active: ${cycles.join(', ')}` : 'No active cycles');
    } else {
      log('No active cycle. Run: forge new <feature>');
    }
  },

  complete(file) {
    const archive = p => fs.renameSync(p, 
      `.forge/history/${path.basename(p, '.md')}-${timestamp()}.md`);
    
    if (file && exists(`.forge/current/${file}`)) {
      archive(`.forge/current/${file}`);
    } else if (exists('.forge/current.md')) {
      archive('.forge/current.md');
    } else {
      return log('No cycle to complete');
    }
    log('‚úÖ Completed');
  },

  learn(action) {
    const lpath = '.forge/LEARNINGS.md';
    const actions = {
      retrospective: () => log(tpl('retrospective.md')),
      pattern: () => log(tpl('pattern.md')),
      claude: () => (write('CLAUDE.md', tpl('CLAUDE.md')), log('üìù Created CLAUDE.md'))
    };
    
    if (!action) {
      exists(lpath) ? log(fs.readFileSync(lpath, 'utf8'))
        : (write(lpath, tpl('LEARNINGS.md')), log('üìö Created learnings'));
    } else {
      actions[action]?.() || log('Options: retrospective|pattern|claude');
    }
  },

  document: () => (write('.forge/DOCUMENT_SESSION.md', tpl('document-session.md')), 
    log('üìö Documentation session started')),

  uninstall: () => args[0] === '--confirm'
    ? (['forge.yaml','.forge'].forEach(p => exists(p) && fs.rmSync(p, {recursive:true})), log('‚úÖ Done'))
    : log('Add --confirm to uninstall')
};

// Execute command or show help
if (commands[cmd]) {
  commands[cmd](...args);
} else {
  log(`üî® FORGE Framework

Commands:
  init         Initialize FORGE
  new <name>   Start feature cycle  
  status       Show current cycle
  complete     Archive cycle
  learn        View/manage learnings
  document     Start documentation
  uninstall    Remove FORGE

Learn: retrospective | pattern | claude`);
}