#!/usr/bin/env node
/**
 * FORGE Framework - AI-driven development through natural conversation
 * Created by Scott Feltham - https://github.com/scottfeltham/forge-framework
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const [,, cmd, ...args] = process.argv;

// Helpers
const log = console.log;
const tpl = n => fs.readFileSync(path.join(process.cwd(), '.forge/templates', n), 'utf8');
const write = (p, c) => fs.writeFileSync(p, c);
const exists = p => fs.existsSync(p);
const timestamp = () => new Date().toISOString().replace(/[:.]/g, '-');

// Phase validation helpers
const parsePhaseProgress = (content) => {
  const phases = {
    'Focus': { name: 'Focus', icon: 'üéØ', items: [], complete: false },
    'Orchestrate': { name: 'Orchestrate', icon: 'üìù', items: [], complete: false },
    'Refine': { name: 'Refine', icon: 'üî®', items: [], complete: false },
    'Generate': { name: 'Generate', icon: 'üöÄ', items: [], complete: false },
    'Evaluate': { name: 'Evaluate', icon: 'üìä', items: [], complete: false }
  };
  
  const lines = content.split('\n');
  let currentPhase = null;
  
  lines.forEach(line => {
    // Detect phase headers
    if (line.includes('Phase 1: Focus')) currentPhase = 'Focus';
    else if (line.includes('Phase 2: Orchestrate')) currentPhase = 'Orchestrate';
    else if (line.includes('Phase 3: Refine')) currentPhase = 'Refine';
    else if (line.includes('Phase 4: Generate')) currentPhase = 'Generate';
    else if (line.includes('Phase 5: Evaluate')) currentPhase = 'Evaluate';
    
    // Parse checkboxes
    if (currentPhase && line.trim().startsWith('- [')) {
      const isChecked = line.includes('[x]') || line.includes('[X]');
      const isMandatory = line.toLowerCase().includes('mandatory');
      const text = line.replace(/- \[[x ]\]/i, '').trim();
      
      if (text && !text.includes('Consider parallel')) {
        phases[currentPhase].items.push({ 
          text: text.substring(0, 50), 
          checked: isChecked,
          mandatory: isMandatory
        });
      }
    }
  });
  
  // Calculate completion
  Object.values(phases).forEach(phase => {
    if (phase.items.length > 0) {
      const mandatoryItems = phase.items.filter(i => i.mandatory);
      const completedMandatory = mandatoryItems.filter(i => i.checked);
      const completedAll = phase.items.filter(i => i.checked);
      
      phase.complete = mandatoryItems.length === 0 
        ? completedAll.length === phase.items.length
        : completedMandatory.length === mandatoryItems.length;
      
      phase.progress = phase.items.length > 0 
        ? Math.round((completedAll.length / phase.items.length) * 100)
        : 0;
    }
  });
  
  return phases;
};

const validateCycleCompletion = (content) => {
  const phases = parsePhaseProgress(content);
  const incompletePhases = [];
  const incompleteTasks = [];
  
  Object.entries(phases).forEach(([name, phase]) => {
    if (phase.items.length > 0 && !phase.complete) {
      incompletePhases.push(name);
      const incomplete = phase.items.filter(i => !i.checked && i.mandatory);
      incomplete.forEach(task => {
        incompleteTasks.push(`  ${phase.icon} ${name}: ${task.text}`);
      });
    }
  });
  
  return {
    isComplete: incompletePhases.length === 0,
    incompletePhases,
    incompleteTasks,
    phases
  };
};

// Load MCP registry
const mcpServers = exists(path.join(__dirname, 'recommended-mcp-servers.json')) 
  ? JSON.parse(fs.readFileSync(path.join(__dirname, 'recommended-mcp-servers.json'), 'utf8'))
  : null;

// Ensure .forge exists
if (!exists('.forge')) fs.mkdirSync('.forge/history', { recursive: true });

const commands = {
  init() {
    if (exists('forge.yaml')) return log('‚ö†Ô∏è  Already initialized');
    write('forge.yaml', `# FORGE Configuration
project: ${path.basename(process.cwd())}
mode: conversational
ai: {primary: claude, model: sonnet}`);
    write('.forge/INIT_ANALYSIS.md', tpl('init-prompt.md'));
    log('üî® FORGE initialized!\n\nü§ñ Claude will analyze your project...');
  },

  new(name) {
    if (!name) return log('Usage: forge new <feature>');
    const cycle = tpl('cycle.md')
      .replace(/{{FEATURE}}/g, name)
      .replace(/{{DATE}}/g, new Date().toISOString().split('T')[0]);
    
    const isTeam = exists('forge.yaml') && 
      fs.readFileSync('forge.yaml', 'utf8').includes('collaborative');
    
    if (isTeam) {
      const dir = '.forge/current';
      if (!exists(dir)) fs.mkdirSync(dir, { recursive: true });
      const file = `${name.toLowerCase().replace(/\s+/g, '-')}.md`;
      write(`${dir}/${file}`, cycle);
      log(`‚ú® Started: ${name}\nüìÅ Created: ${dir}/${file}`);
    } else {
      write('.forge/current.md', cycle);
      log(`‚ú® Started: ${name}\nüìã Phase: Focus\nü§ñ Claude will guide you`);
    }
  },

  status() {
    // Check for --detailed flag
    const detailed = args.includes('--detailed');
    
    const current = '.forge/current.md';
    if (exists(current)) {
      const content = fs.readFileSync(current, 'utf8');
      
      if (detailed) {
        // Show full content
        log(content);
      } else {
        // Show progress summary
        const lines = content.split('\n');
        const featureLine = lines.find(l => l.startsWith('# Feature:'));
        const feature = featureLine ? featureLine.replace('# Feature:', '').trim() : 'Unknown';
        
        const validation = validateCycleCompletion(content);
        
        log(`\nüìã Current Cycle: ${feature}`);
        log('‚îÄ'.repeat(50));
        
        // Show phase progress
        Object.entries(validation.phases).forEach(([name, phase]) => {
          if (phase.items.length > 0) {
            const progressBar = '‚ñà'.repeat(Math.floor(phase.progress / 10)) + 
                               '‚ñë'.repeat(10 - Math.floor(phase.progress / 10));
            const status = phase.complete ? '‚úÖ' : phase.progress > 0 ? 'üîÑ' : '‚è≥';
            
            log(`${status} ${phase.icon} ${name.padEnd(12)} [${progressBar}] ${phase.progress}%`);
          }
        });
        
        // Show current status
        const currentPhase = Object.entries(validation.phases)
          .find(([_, p]) => p.items.length > 0 && !p.complete);
        
        if (currentPhase) {
          log('\nüìç Current Phase: ' + currentPhase[0]);
          const incomplete = currentPhase[1].items.filter(i => !i.checked);
          if (incomplete.length > 0 && incomplete.length <= 3) {
            log('   Next tasks:');
            incomplete.slice(0, 3).forEach(task => {
              log(`   ‚Ä¢ ${task.text}`);
            });
          }
        } else if (validation.isComplete) {
          log('\n‚ú® All phases complete! Ready to archive with "forge complete"');
        }
        
        log('\nüí° Use "forge status --detailed" for full cycle view');
      }
    } else if (exists('.forge/current')) {
      const cycles = fs.readdirSync('.forge/current').filter(f => f.endsWith('.md'));
      if (cycles.length) {
        log('üìä Active cycles (team mode):');
        cycles.forEach(c => log(`  ‚Ä¢ ${c.replace('.md', '')}`));
        log('\nUse "forge status <cycle-name>.md" for details');
      } else {
        log('No active cycles');
      }
    } else {
      log('No active cycle. Run: forge new <feature>');
    }
  },

  complete(file) {
    // Determine which file to complete
    let cyclePath;
    if (file && exists(`.forge/current/${file}`)) {
      cyclePath = `.forge/current/${file}`;
    } else if (exists('.forge/current.md')) {
      cyclePath = '.forge/current.md';
    } else {
      return log('No cycle to complete');
    }
    
    // Check for --force flag
    const forceComplete = args.includes('--force');
    
    if (!forceComplete) {
      // Validate cycle completion
      const content = fs.readFileSync(cyclePath, 'utf8');
      const validation = validateCycleCompletion(content);
      
      if (!validation.isComplete) {
        log('‚ö†Ô∏è  Cycle has incomplete phases!\n');
        log('Incomplete phases:', validation.incompletePhases.join(', '));
        
        if (validation.incompleteTasks.length > 0) {
          log('\nMandatory tasks not completed:');
          validation.incompleteTasks.forEach(task => log(task));
        }
        
        log('\nüí° Options:');
        log('  1. Complete the remaining tasks');
        log('  2. Use "forge complete --force" to archive anyway');
        log('  3. Use "forge status" to see detailed progress');
        return;
      }
    }
    
    // Archive the cycle
    const archivePath = `.forge/history/cycle-${timestamp()}.md`;
    fs.renameSync(cyclePath, archivePath);
    
    if (forceComplete) {
      log('‚ö†Ô∏è  Cycle archived (forced completion)');
    } else {
      log('‚úÖ Cycle completed successfully!');
    }
    log(`üìÅ Archived to: ${archivePath}`);
  },

  learn(action) {
    const lpath = '.forge/LEARNINGS.md';
    const actions = {
      retrospective: () => log(tpl('retrospective.md')),
      pattern: () => log(tpl('pattern.md')),
      claude: () => (write('CLAUDE.md', tpl('CLAUDE.md')), log('üìù Created CLAUDE.md'))
    };
    
    if (!action) {
      exists(lpath) ? log(fs.readFileSync(lpath, 'utf8'))
        : (write(lpath, tpl('LEARNINGS.md')), log('üìö Created learnings'));
    } else {
      actions[action]?.() || log('Options: retrospective|pattern|claude');
    }
  },

  document: () => (write('.forge/DOCUMENT_SESSION.md', tpl('document-session.md')), 
    log('üìö Documentation session started')),

  uninstall: () => args[0] === '--confirm'
    ? (['forge.yaml','.forge'].forEach(p => exists(p) && fs.rmSync(p, {recursive:true})), log('‚úÖ Done'))
    : log('Add --confirm to uninstall'),
  
  phase(action) {
    const current = '.forge/current.md';
    if (!exists(current)) {
      return log('No active cycle. Run: forge new <feature>');
    }
    
    const content = fs.readFileSync(current, 'utf8');
    const validation = validateCycleCompletion(content);
    
    const subcommands = {
      status: () => {
        log('\nüìä Phase Progress Overview');
        log('‚îÄ'.repeat(50));
        
        Object.entries(validation.phases).forEach(([name, phase]) => {
          if (phase.items.length > 0) {
            const progressBar = '‚ñà'.repeat(Math.floor(phase.progress / 10)) + 
                               '‚ñë'.repeat(10 - Math.floor(phase.progress / 10));
            const status = phase.complete ? '‚úÖ' : phase.progress > 0 ? 'üîÑ' : '‚è≥';
            
            log(`${status} ${phase.icon} ${name.padEnd(12)} [${progressBar}] ${phase.progress}%`);
            
            // Show incomplete mandatory items
            const mandatoryIncomplete = phase.items.filter(i => i.mandatory && !i.checked);
            if (mandatoryIncomplete.length > 0) {
              mandatoryIncomplete.forEach(item => {
                log(`     ‚ö†Ô∏è  ${item.text}`);
              });
            }
          }
        });
      },
      
      next: () => {
        // Find current phase
        const phaseOrder = ['Focus', 'Orchestrate', 'Refine', 'Generate', 'Evaluate'];
        let currentPhaseIndex = -1;
        
        for (let i = 0; i < phaseOrder.length; i++) {
          const phase = validation.phases[phaseOrder[i]];
          if (phase.items.length > 0 && !phase.complete) {
            currentPhaseIndex = i;
            break;
          }
        }
        
        if (currentPhaseIndex === -1) {
          return log('‚úÖ All phases complete! Use "forge complete" to archive.');
        }
        
        const currentPhaseName = phaseOrder[currentPhaseIndex];
        const currentPhase = validation.phases[currentPhaseName];
        
        // Check if current phase has mandatory incomplete items
        const mandatoryIncomplete = currentPhase.items.filter(i => i.mandatory && !i.checked);
        if (mandatoryIncomplete.length > 0) {
          log(`‚ö†Ô∏è  Cannot move to next phase. Current phase "${currentPhaseName}" has incomplete mandatory items:`);
          mandatoryIncomplete.forEach(item => {
            log(`   ‚Ä¢ ${item.text}`);
          });
          log('\nüí° Complete these items or use "forge phase next --force" to skip validation');
          return;
        }
        
        // Mark current phase as complete in the file
        let updatedContent = content;
        const phaseHeaders = {
          'Focus': 'Phase 1: Focus',
          'Orchestrate': 'Phase 2: Orchestrate',
          'Refine': 'Phase 3: Refine',
          'Generate': 'Phase 4: Generate',
          'Evaluate': 'Phase 5: Evaluate'
        };
        
        // Update phase status in content
        updatedContent = updatedContent.replace(
          `### ${phaseHeaders[currentPhaseName]} üéØ [Active]`,
          `### ${phaseHeaders[currentPhaseName]} ‚úÖ [Complete]`
        );
        
        // Activate next phase if available
        if (currentPhaseIndex < phaseOrder.length - 1) {
          const nextPhaseName = phaseOrder[currentPhaseIndex + 1];
          const nextPhaseHeader = phaseHeaders[nextPhaseName];
          updatedContent = updatedContent.replace(
            new RegExp(`### ${nextPhaseHeader} .* \\[Pending\\]`),
            `### ${nextPhaseHeader} üéØ [Active]`
          );
          
          write(current, updatedContent);
          log(`‚úÖ Moved from ${currentPhaseName} to ${nextPhaseName}`);
        } else {
          write(current, updatedContent);
          log('‚úÖ Final phase complete! Ready to use "forge complete"');
        }
      },
      
      complete: () => {
        // Find and mark current active phase as complete
        const phaseOrder = ['Focus', 'Orchestrate', 'Refine', 'Generate', 'Evaluate'];
        let found = false;
        
        for (const phaseName of phaseOrder) {
          const phase = validation.phases[phaseName];
          if (phase.items.length > 0 && !phase.complete) {
            // Mark all items as complete
            let updatedContent = content;
            const lines = updatedContent.split('\n');
            let inPhase = false;
            let phaseHeader = `Phase ${phaseOrder.indexOf(phaseName) + 1}: ${phaseName}`;
            
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].includes(phaseHeader)) {
                inPhase = true;
                // Mark phase as complete
                lines[i] = lines[i].replace('[Active]', '[Complete]');
              } else if (inPhase && lines[i].includes('Phase') && lines[i].includes(':')) {
                inPhase = false;
              } else if (inPhase && lines[i].trim().startsWith('- [ ]')) {
                lines[i] = lines[i].replace('- [ ]', '- [x]');
              }
            }
            
            write(current, lines.join('\n'));
            log(`‚úÖ Marked ${phaseName} phase as complete`);
            found = true;
            break;
          }
        }
        
        if (!found) {
          log('‚úÖ All phases already complete!');
        }
      }
    };
    
    if (!action || !subcommands[action]) {
      log('Usage: forge phase [status|next|complete]');
      log('  status   - Show detailed phase progress');
      log('  next     - Move to next phase (with validation)');
      log('  complete - Mark current phase as complete');
    } else {
      subcommands[action]();
    }
  },

  mcp(action = 'list') {
    if (!mcpServers) return log('MCP registry not found');
    
    const subcommands = {
      list: () => {
        log('üîå Available MCP Servers:\n');
        Object.entries(mcpServers.servers).forEach(([key, srv]) => {
          log(`  ${srv.recommended ? '‚≠ê' : '  '} ${key.padEnd(15)} ${srv.description}`);
        });
        log('\nüí° Run: forge mcp add <server>');
      },
      
      add: () => {
        const server = args[1];
        if (!server || !mcpServers.servers[server]) {
          return log('Usage: forge mcp add <server>\nRun "forge mcp list" to see available servers');
        }
        
        const srv = mcpServers.servers[server];
        const config = exists('forge.yaml') ? yaml.load(fs.readFileSync('forge.yaml', 'utf8')) : {};
        
        if (!config.mcp) config.mcp = { enabled: true, servers: [] };
        
        const serverConfig = {
          name: srv.name,
          command: srv.command,
          args: srv.args
        };
        
        if (srv.env) serverConfig.env = srv.env;
        
        config.mcp.servers.push(serverConfig);
        write('forge.yaml', yaml.dump(config));
        
        log(`‚úÖ Added ${server} to forge.yaml`);
        if (srv.env) {
          log(`\n‚ö†Ô∏è  Set environment variables:`);
          Object.keys(srv.env).forEach(k => log(`   export ${k}=your_value`));
        }
      },
      
      suggest: () => {
        const config = exists('forge.yaml') ? yaml.load(fs.readFileSync('forge.yaml', 'utf8')) : {};
        const projectType = config.projectType || 'web';
        const suggested = mcpServers.projectTypes[projectType] || mcpServers.projectTypes.web;
        
        log(`üìã Suggested MCP servers for ${projectType} project:\n`);
        suggested.forEach(s => {
          const srv = mcpServers.servers[s];
          if (srv) log(`  ‚Ä¢ ${s}: ${srv.description}`);
        });
        log(`\nüí° Add all: forge mcp add ${suggested.join(' ')}`);
      }
    };
    
    (subcommands[action] || subcommands.list)();
  }
};

// Execute command or show help
if (commands[cmd]) {
  commands[cmd](...args);
} else {
  log(`üî® FORGE Framework

Commands:
  init         Initialize FORGE
  new <name>   Start feature cycle  
  status       Show current cycle (--detailed for full view)
  phase        Manage cycle phases
  complete     Archive cycle (--force to skip validation)
  learn        View/manage learnings
  document     Start documentation
  mcp          Manage MCP servers
  uninstall    Remove FORGE

Phase: status | next | complete
Learn: retrospective | pattern | claude
MCP: list | suggest | add <server>`);
}