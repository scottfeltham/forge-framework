#!/usr/bin/env node
/**
 * FORGE Framework - AI-driven development through natural conversation
 * Created by Scott Feltham - https://github.com/scottfeltham/forge-framework
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const [,, cmd, ...args] = process.argv;

// Helpers
const log = console.log;
const getTemplatesPath = () => {
  // Check if running locally (with .forge directory)
  const localTemplatesPath = path.join(process.cwd(), '.forge', 'templates');
  if (fs.existsSync(localTemplatesPath)) {
    return localTemplatesPath;
  }
  
  // Use templates relative to forge script location
  return path.join(__dirname, 'templates');
};

// Secure slug creation with validation
const createSlug = (name) => {
  if (!name || typeof name !== 'string') {
    throw new Error('Feature name is required and must be a string');
  }
  
  // Remove dangerous characters and normalize
  let slug = name.toLowerCase()
    .replace(/[^a-z0-9\s\-_]/g, '') // Remove non-alphanumeric, spaces, hyphens, underscores
    .replace(/\s+/g, '-')          // Replace spaces with hyphens
    .replace(/-+/g, '-')           // Remove multiple consecutive hyphens
    .replace(/^-+|-+$/g, '');      // Remove leading/trailing hyphens
  
  // Validate slug
  if (!slug) {
    throw new Error('Feature name must contain at least one valid character');
  }
  
  if (slug.length > 50) {
    slug = slug.substring(0, 50).replace(/-+$/, '');
  }
  
  // Prevent path traversal
  if (slug.includes('..') || slug.includes('/') || slug.includes('\\')) {
    throw new Error('Feature name contains invalid path characters');
  }
  
  return slug;
};

const tpl = n => fs.readFileSync(path.join(getTemplatesPath(), n), 'utf8');
const write = (p, c) => fs.writeFileSync(p, c);
const exists = p => fs.existsSync(p);
const timestamp = () => new Date().toISOString().replace(/[:.]/g, '-');

// Centralized phase configuration
const PHASES = {
  Focus: { order: 0, icon: 'üéØ', header: 'Phase 1: Focus' },
  Orchestrate: { order: 1, icon: 'üìù', header: 'Phase 2: Orchestrate' },
  Refine: { order: 2, icon: 'üî®', header: 'Phase 3: Refine' },
  Generate: { order: 3, icon: 'üöÄ', header: 'Phase 4: Generate' },
  Evaluate: { order: 4, icon: 'üìä', header: 'Phase 5: Evaluate' }
};

// Get ordered phase names array
const getPhaseOrder = () => Object.keys(PHASES).sort((a, b) => PHASES[a].order - PHASES[b].order);

// Get phase by order index
const getPhaseByIndex = (index) => {
  const ordered = getPhaseOrder();
  return ordered[index] || null;
};

// Phase validation helpers
const parsePhaseProgress = (content) => {
  const phases = {
    'Focus': { name: 'Focus', icon: 'üéØ', items: [], complete: false },
    'Orchestrate': { name: 'Orchestrate', icon: 'üìù', items: [], complete: false },
    'Refine': { name: 'Refine', icon: 'üî®', items: [], complete: false },
    'Generate': { name: 'Generate', icon: 'üöÄ', items: [], complete: false },
    'Evaluate': { name: 'Evaluate', icon: 'üìä', items: [], complete: false }
  };
  
  const lines = content.split('\n');
  let currentPhase = null;
  
  lines.forEach(line => {
    // Use machine-readable phase markers first (new format)
    const phaseMarkerMatch = line.match(/<!-- FORGE_PHASE:(\w+):\w+ -->/);
    if (phaseMarkerMatch) {
      const phaseName = phaseMarkerMatch[1];
      if (phases[phaseName]) {
        currentPhase = phaseName;
      }
    } 
    // Fallback to legacy detection for older templates
    else if (line.includes('Phase 1: Focus')) currentPhase = 'Focus';
    else if (line.includes('Phase 2: Orchestrate')) currentPhase = 'Orchestrate';
    else if (line.includes('Phase 3: Refine')) currentPhase = 'Refine';
    else if (line.includes('Phase 4: Generate')) currentPhase = 'Generate';
    else if (line.includes('Phase 5: Evaluate')) currentPhase = 'Evaluate';
    
    // Parse checkboxes
    if (currentPhase && line.trim().startsWith('- [')) {
      const isChecked = line.includes('[x]') || line.includes('[X]');
      const isMandatory = line.toLowerCase().includes('mandatory');
      const text = line.replace(/- \[[x ]\]/i, '').trim();
      
      if (text && !text.includes('Consider parallel')) {
        phases[currentPhase].items.push({ 
          text: text.substring(0, 50), 
          checked: isChecked,
          mandatory: isMandatory
        });
      }
    }
  });
  
  // Calculate completion
  Object.values(phases).forEach(phase => {
    if (phase.items.length > 0) {
      const mandatoryItems = phase.items.filter(i => i.mandatory);
      const completedMandatory = mandatoryItems.filter(i => i.checked);
      const completedAll = phase.items.filter(i => i.checked);
      
      phase.complete = mandatoryItems.length === 0 
        ? completedAll.length === phase.items.length
        : completedMandatory.length === mandatoryItems.length;
      
      phase.progress = phase.items.length > 0 
        ? Math.round((completedAll.length / phase.items.length) * 100)
        : 0;
    }
  });
  
  return phases;
};

const validateCycleCompletion = (content) => {
  const phases = parsePhaseProgress(content);
  const incompletePhases = [];
  const incompleteTasks = [];
  
  Object.entries(phases).forEach(([name, phase]) => {
    if (phase.items.length > 0 && !phase.complete) {
      incompletePhases.push(name);
      const incomplete = phase.items.filter(i => !i.checked && i.mandatory);
      incomplete.forEach(task => {
        incompleteTasks.push(`  ${phase.icon} ${name}: ${task.text}`);
      });
    }
  });
  
  return {
    isComplete: incompletePhases.length === 0,
    incompletePhases,
    incompleteTasks,
    phases
  };
};

// Simplified phase detection using string operations
const findActivePhase = (content) => {
  const phaseOrder = getPhaseOrder();
  
  // First look for explicitly active phase
  for (const phaseName of phaseOrder) {
    const header = PHASES[phaseName].header;
    const activeMarker = `### ${header} üéØ [Active]`;
    
    if (content.includes(activeMarker)) {
      return { name: phaseName, index: PHASES[phaseName].order };
    }
  }
  
  // If no active phase found, find next phase after highest completed
  let highestCompleteIndex = -1;
  
  for (const phaseName of phaseOrder) {
    const header = PHASES[phaseName].header;
    const completeMarker = `### ${header} ‚úÖ [Complete]`;
    
    if (content.includes(completeMarker)) {
      highestCompleteIndex = PHASES[phaseName].order;
    }
  }
  
  // Return next phase after highest completed
  const nextIndex = highestCompleteIndex + 1;
  const nextPhaseName = getPhaseByIndex(nextIndex);
  
  if (nextPhaseName) {
    return { name: nextPhaseName, index: nextIndex };
  }
  
  return null; // All phases complete
};

// Check if a phase is marked complete in headers  
const isPhaseMarkedComplete = (content, phaseName) => {
  const header = PHASES[phaseName].header;
  const completeMarker = `### ${header} ‚úÖ [Complete]`;
  return content.includes(completeMarker);
};

// Check if current phase items are all completed
const isPhaseItemsComplete = (content, phaseName) => {
  const phases = parsePhaseProgress(content);
  const phase = phases[phaseName];
  if (!phase || phase.items.length === 0) return true;
  
  // All items must be checked for completion
  return phase.items.every(item => item.checked);
};

// Update phase state in content using simple string replacement
const updatePhaseState = (content, phaseName, newState) => {
  const header = PHASES[phaseName].header;
  const phaseIcon = PHASES[phaseName].icon;
  const stateEmojis = {
    'Active': 'üéØ',
    'Complete': '‚úÖ', 
    'Pending': phaseIcon
  };
  
  // Find current state and replace with new state
  const states = ['Active', 'Complete', 'Pending'];
  let updatedContent = content;
  
  for (const currentState of states) {
    const currentEmoji = currentState === 'Pending' ? phaseIcon : stateEmojis[currentState];
    const newEmoji = newState === 'Pending' ? phaseIcon : stateEmojis[newState];
    
    const currentMarker = `### ${header} ${currentEmoji} [${currentState}]`;
    const newMarker = `### ${header} ${newEmoji} [${newState}]`;
    
    if (updatedContent.includes(currentMarker)) {
      updatedContent = updatedContent.replace(currentMarker, newMarker);
      break;
    }
  }
  
  return updatedContent;
};

// Consolidated validation logic
const validatePhaseTransition = (content, phaseName, forceSkip = false) => {
  if (forceSkip) return { canTransition: true };
  
  const isHeaderComplete = isPhaseMarkedComplete(content, phaseName);
  const areItemsComplete = isPhaseItemsComplete(content, phaseName);
  
  if (isHeaderComplete || areItemsComplete) {
    return { canTransition: true };
  }
  
  // Get incomplete items for error message
  const phases = parsePhaseProgress(content);
  const phase = phases[phaseName];
  const incompleteItems = phase ? phase.items.filter(i => !i.checked) : [];
  
  return {
    canTransition: false,
    incompleteItems,
    phase: phase
  };
};

// Format incomplete items for error messages
const formatIncompleteItems = (incompleteItems, limit = 5) => {
  if (!incompleteItems || incompleteItems.length === 0) return [];
  
  const messages = [];
  const itemsToShow = incompleteItems.slice(0, limit);
  
  itemsToShow.forEach(item => {
    const mandatory = item.mandatory ? ' (MANDATORY)' : '';
    messages.push(`   ‚Ä¢ ${item.text}${mandatory}`);
  });
  
  if (incompleteItems.length > limit) {
    messages.push(`   ... and ${incompleteItems.length - limit} more items`);
  }
  
  return messages;
};

// Mark all checkboxes as complete in a phase section
const markPhaseItemsComplete = (content, phaseName) => {
  const header = PHASES[phaseName].header;
  const lines = content.split('\n');
  let inPhase = false;
  
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes(`### ${header}`)) {
      inPhase = true;
    } else if (inPhase && lines[i].includes('### Phase')) {
      inPhase = false;
    } else if (inPhase && lines[i].trim().startsWith('- [ ]')) {
      lines[i] = lines[i].replace('- [ ]', '- [x]');
    }
  }
  
  return lines.join('\n');
};

// Load MCP registry
const mcpServers = exists(path.join(__dirname, 'recommended-mcp-servers.json')) 
  ? JSON.parse(fs.readFileSync(path.join(__dirname, 'recommended-mcp-servers.json'), 'utf8'))
  : null;

// Ensure .forge exists
if (!exists('.forge')) fs.mkdirSync('.forge/history', { recursive: true });

const commands = {
  init() {
    if (exists('forge.yaml')) return log('‚ö†Ô∏è  Already initialized');
    write('forge.yaml', `# FORGE Configuration
project: ${path.basename(process.cwd())}
mode: conversational
ai: {primary: claude, model: sonnet}`);
    write('.forge/INIT_ANALYSIS.md', tpl('init-prompt.md'));
    log('üî® FORGE initialized!\n\nü§ñ Claude will analyze your project...');
  },

  new(name) {
    if (!name) return log('Usage: forge new <feature>');
    
    try {
      const slug = createSlug(name);
      const cycle = tpl('cycle.md')
        .replace(/{{FEATURE}}/g, name)
        .replace(/{{DATE}}/g, new Date().toISOString().split('T')[0]);
      
      const isTeam = exists('forge.yaml') && 
        fs.readFileSync('forge.yaml', 'utf8').includes('collaborative');
      
      if (isTeam) {
        const dir = '.forge/current';
        if (!exists(dir)) fs.mkdirSync(dir, { recursive: true });
        const file = `${slug}.md`;
        const fullPath = path.join(dir, file);
        
        // Ensure the resolved path is still under .forge/current
        if (!fullPath.startsWith(path.resolve(dir))) {
          throw new Error('Invalid feature name: path traversal detected');
        }
        
        write(fullPath, cycle);
        log(`‚ú® Started: ${name}\nüìÅ Created: ${dir}/${file}`);
      } else {
        write('.forge/current.md', cycle);
        log(`‚ú® Started: ${name}\nüìã Phase: Focus\nü§ñ Claude will guide you`);
      }
    } catch (error) {
      log(`‚ùå Error creating cycle: ${error.message}`);
      log('üí° Feature names should contain only letters, numbers, spaces, hyphens, and underscores');
    }
  },

  status(cycleName) {
    // Check for --detailed flag
    const detailed = args.includes('--detailed');
    
    // Handle team mode cycle selection
    if (cycleName && exists('.forge/current')) {
      const teamCyclePath = path.join('.forge/current', cycleName);
      if (exists(teamCyclePath)) {
        const content = fs.readFileSync(teamCyclePath, 'utf8');
        if (detailed) {
          log(content);
        } else {
          // Show progress summary for specific team cycle
          const lines = content.split('\n');
          const featureLine = lines.find(l => l.startsWith('# Feature:'));
          const feature = featureLine ? featureLine.replace('# Feature:', '').trim() : cycleName.replace('.md', '');
          
          const validation = validateCycleCompletion(content);
          
          log(`\nüìã Team Cycle: ${feature}`);
          log('‚îÄ'.repeat(50));
          
          // Show phase progress
          Object.entries(validation.phases).forEach(([name, phase]) => {
            if (phase.items.length > 0) {
              const progressBar = '‚ñà'.repeat(Math.floor(phase.progress / 10)) + 
                                 '‚ñë'.repeat(10 - Math.floor(phase.progress / 10));
              const status = phase.complete ? '‚úÖ' : phase.progress > 0 ? 'üîÑ' : '‚è≥';
              
              log(`${status} ${phase.icon} ${name.padEnd(12)} [${progressBar}] ${phase.progress}%`);
            }
          });
          
          // Show current status using header-based phase detection
          const activePhase = findActivePhase(content);
          
          if (activePhase) {
            log(`\nüìç Current Phase: ${activePhase.name}`);
            const currentPhaseData = validation.phases[activePhase.name];
            if (currentPhaseData && currentPhaseData.items) {
              const incomplete = currentPhaseData.items.filter(i => !i.checked);
              if (incomplete.length > 0 && incomplete.length <= 3) {
                log('   Next tasks:');
                incomplete.slice(0, 3).forEach(task => {
                  log(`   ‚Ä¢ ${task.text}`);
                });
              }
            }
          } else {
            log('\n‚ú® All phases complete! Ready to archive with "forge complete"');
          }
          
          log('\nüí° Use "forge status --detailed" for full cycle view');
        }
        return;
      } else {
        log(`‚ùå Team cycle not found: ${cycleName}`);
        log('Available cycles:');
        const cycles = fs.readdirSync('.forge/current').filter(f => f.endsWith('.md'));
        cycles.forEach(c => log(`  ‚Ä¢ ${c}`));
        return;
      }
    }
    
    const current = '.forge/current.md';
    if (exists(current)) {
      const content = fs.readFileSync(current, 'utf8');
      
      if (detailed) {
        // Show full content
        log(content);
      } else {
        // Show progress summary
        const lines = content.split('\n');
        const featureLine = lines.find(l => l.startsWith('# Feature:'));
        const feature = featureLine ? featureLine.replace('# Feature:', '').trim() : 'Unknown';
        
        const validation = validateCycleCompletion(content);
        
        log(`\nüìã Current Cycle: ${feature}`);
        log('‚îÄ'.repeat(50));
        
        // Show phase progress
        Object.entries(validation.phases).forEach(([name, phase]) => {
          if (phase.items.length > 0) {
            const progressBar = '‚ñà'.repeat(Math.floor(phase.progress / 10)) + 
                               '‚ñë'.repeat(10 - Math.floor(phase.progress / 10));
            const status = phase.complete ? '‚úÖ' : phase.progress > 0 ? 'üîÑ' : '‚è≥';
            
            log(`${status} ${phase.icon} ${name.padEnd(12)} [${progressBar}] ${phase.progress}%`);
          }
        });
        
        // Show current status using header-based phase detection
        const activePhase = findActivePhase(content);
        
        if (activePhase) {
          log(`\nüìç Current Phase: ${activePhase.name}`);
          const currentPhaseData = validation.phases[activePhase.name];
          if (currentPhaseData && currentPhaseData.items) {
            const incomplete = currentPhaseData.items.filter(i => !i.checked);
            if (incomplete.length > 0 && incomplete.length <= 3) {
              log('   Next tasks:');
              incomplete.slice(0, 3).forEach(task => {
                log(`   ‚Ä¢ ${task.text}`);
              });
            }
          }
        } else {
          log('\n‚ú® All phases complete! Ready to archive with "forge complete"');
        }
        
        log('\nüí° Use "forge status --detailed" for full cycle view');
      }
    } else if (exists('.forge/current')) {
      const cycles = fs.readdirSync('.forge/current').filter(f => f.endsWith('.md'));
      if (cycles.length) {
        log('üìä Active cycles (team mode):');
        cycles.forEach(c => log(`  ‚Ä¢ ${c.replace('.md', '')}`));
        log('\nUse "forge status <cycle-name>.md" for details');
      } else {
        log('No active cycles');
      }
    } else {
      log('No active cycle. Run: forge new <feature>');
    }
  },

  complete(file) {
    // Determine which file to complete
    let cyclePath;
    if (file && exists(`.forge/current/${file}`)) {
      cyclePath = `.forge/current/${file}`;
    } else if (exists('.forge/current.md')) {
      cyclePath = '.forge/current.md';
    } else {
      return log('No cycle to complete');
    }
    
    // Check for --force flag
    const forceComplete = args.includes('--force');
    
    if (!forceComplete) {
      // Validate cycle completion
      const content = fs.readFileSync(cyclePath, 'utf8');
      const validation = validateCycleCompletion(content);
      
      if (!validation.isComplete) {
        log('‚ö†Ô∏è  Cycle has incomplete phases!\n');
        log('Incomplete phases:', validation.incompletePhases.join(', '));
        
        if (validation.incompleteTasks.length > 0) {
          log('\nMandatory tasks not completed:');
          validation.incompleteTasks.forEach(task => log(task));
        }
        
        log('\nüí° Options:');
        log('  1. Complete the remaining tasks');
        log('  2. Use "forge complete --force" to archive anyway');
        log('  3. Use "forge status" to see detailed progress');
        return;
      }
    }
    
    // Archive the cycle
    const historyDir = '.forge/history';
    if (!fs.existsSync(historyDir)) {
      fs.mkdirSync(historyDir, { recursive: true });
    }
    const archivePath = `${historyDir}/cycle-${timestamp()}.md`;
    fs.renameSync(cyclePath, archivePath);
    
    if (forceComplete) {
      log('‚ö†Ô∏è  Cycle archived (forced completion)');
    } else {
      log('‚úÖ Cycle completed successfully!');
    }
    log(`üìÅ Archived to: ${archivePath}`);
  },

  learn(action) {
    const lpath = '.forge/LEARNINGS.md';
    const actions = {
      retrospective: () => log(tpl('retrospective.md')),
      pattern: () => log(tpl('pattern.md')),
      claude: () => (write('CLAUDE.md', tpl('CLAUDE.md')), log('üìù Created CLAUDE.md'))
    };
    
    if (!action) {
      exists(lpath) ? log(fs.readFileSync(lpath, 'utf8'))
        : (write(lpath, tpl('LEARNINGS.md')), log('üìö Created learnings'));
    } else {
      actions[action]?.() || log('Options: retrospective|pattern|claude');
    }
  },

  document: () => (write('.forge/DOCUMENT_SESSION.md', tpl('document-session.md')), 
  log('üìö Documentation session started')),

  uninstall: () => args[0] === '--confirm'
    ? (['forge.yaml','.forge'].forEach(p => exists(p) && fs.rmSync(p, {recursive:true})), log('‚úÖ Done'))
    : log('Add --confirm to uninstall'),
  
  phase(action) {
    const current = '.forge/current.md';
    if (!exists(current)) {
      return log('No active cycle. Run: forge new <feature>');
    }
    
    const content = fs.readFileSync(current, 'utf8');
    const validation = validateCycleCompletion(content);
    
    const subcommands = {
      status: () => {
        log('\nüìä Phase Progress Overview');
        log('‚îÄ'.repeat(50));
        
        Object.entries(validation.phases).forEach(([name, phase]) => {
          if (phase.items.length > 0) {
            const progressBar = '‚ñà'.repeat(Math.floor(phase.progress / 10)) + 
                               '‚ñë'.repeat(10 - Math.floor(phase.progress / 10));
            const status = phase.complete ? '‚úÖ' : phase.progress > 0 ? 'üîÑ' : '‚è≥';
            
            log(`${status} ${phase.icon} ${name.padEnd(12)} [${progressBar}] ${phase.progress}%`);
            
            // Show incomplete mandatory items
            const mandatoryIncomplete = phase.items.filter(i => i.mandatory && !i.checked);
            if (mandatoryIncomplete.length > 0) {
              mandatoryIncomplete.forEach(item => {
                log(`     ‚ö†Ô∏è  ${item.text}`);
              });
            }
          }
        });
      },
      
      next: () => {
        const activePhase = findActivePhase(content);
        const forceSkip = args.includes('--force');
        
        if (!activePhase) {
          return log('‚ùå No active phase found. Cannot determine current phase.');
        }
        
        const currentPhaseName = activePhase.name;
        const currentPhaseIndex = activePhase.index;
        const phaseOrder = getPhaseOrder();
        
        // Check if we're at the final phase
        if (currentPhaseIndex === phaseOrder.length - 1) {
          return log('‚úÖ Already in final phase (Evaluate). Use "forge complete" to archive cycle.');
        }
        
        // Validate transition
        const validation = validatePhaseTransition(content, currentPhaseName, forceSkip);
        
        if (!validation.canTransition) {
          log(`‚ö†Ô∏è  Cannot advance from ${currentPhaseName} phase. Phase is not complete:`);
          
          if (validation.incompleteItems.length > 0) {
            log('\n   Incomplete items:');
            formatIncompleteItems(validation.incompleteItems).forEach(msg => log(msg));
          }
          
          log('\nüí° Options:');
          log('   1. Complete remaining items in current phase');
          log('   2. Use "forge phase complete" to manually mark phase complete');
          log('   3. Use "forge phase next --force" to skip validation');
          return;
        }
        
        // Perform transition
        const nextPhaseName = getPhaseByIndex(currentPhaseIndex + 1);
        let updatedContent = updatePhaseState(content, currentPhaseName, 'Complete');
        updatedContent = updatePhaseState(updatedContent, nextPhaseName, 'Active');
        
        write(current, updatedContent);
        
        if (forceSkip) {
          log(`‚ö†Ô∏è  Forced transition from ${currentPhaseName} to ${nextPhaseName}`);
        } else {
          log(`‚úÖ Advanced from ${currentPhaseName} to ${nextPhaseName} phase`);
        }
      },
      
      complete: () => {
        const activePhase = findActivePhase(content);
        const forceComplete = args.includes('--force');
        
        if (!activePhase) {
          return log('‚ùå No active phase found to complete.');
        }
        
        const currentPhaseName = activePhase.name;
        
        // Validate completion (unless forcing)
        if (!forceComplete) {
          const validation = validatePhaseTransition(content, currentPhaseName, false);
          
          if (!validation.canTransition) {
            log(`‚ö†Ô∏è  Cannot complete ${currentPhaseName} phase. Items are incomplete:`);
            
            if (validation.incompleteItems.length > 0) {
              formatIncompleteItems(validation.incompleteItems, 3).forEach(msg => log(msg));
            }
            
            log('\nüí° Options:');
            log('   1. Complete remaining items manually');
            log('   2. Use "forge phase complete --force" to force completion');
            return;
          }
        }
        
        // Mark phase as complete
        let updatedContent = updatePhaseState(content, currentPhaseName, 'Complete');
        
        // Also mark all items as complete if forcing
        if (forceComplete) {
          updatedContent = markPhaseItemsComplete(updatedContent, currentPhaseName);
        }
        
        write(current, updatedContent);
        
        if (forceComplete) {
          log(`‚ö†Ô∏è  Force completed ${currentPhaseName} phase (marked all items as done)`);
        } else {
          log(`‚úÖ Completed ${currentPhaseName} phase`);
        }
        
        log('\nüí° Use "forge phase next" to advance to the next phase');
      }
    };
    
    if (!action || !subcommands[action]) {
      log('Usage: forge phase [status|next|complete]');
      log('  status   - Show detailed phase progress');
      log('  next     - Advance to next phase sequentially (--force to skip validation)');
      log('  complete - Mark current active phase as complete (--force to mark items done)');
    } else {
      subcommands[action]();
    }
  },

  mcp(action = 'list') {
    if (!mcpServers) return log('MCP registry not found');
    
    const subcommands = {
      list: () => {
        log('üîå Available MCP Servers:\n');
        Object.entries(mcpServers.servers).forEach(([key, srv]) => {
          log(`  ${srv.recommended ? '‚≠ê' : '  '} ${key.padEnd(15)} ${srv.description}`);
        });
        log('\nüí° Run: forge mcp add <server>');
      },
      
      add: () => {
        const server = args[1];
        if (!server || !mcpServers.servers[server]) {
          return log('Usage: forge mcp add <server>\nRun "forge mcp list" to see available servers');
        }
        
        const srv = mcpServers.servers[server];
        const config = exists('forge.yaml') ? yaml.load(fs.readFileSync('forge.yaml', 'utf8')) : {};
        
        if (!config.mcp) config.mcp = { enabled: true, servers: [] };
        
        const serverConfig = {
          name: srv.name,
          command: srv.command,
          args: srv.args
        };
        
        if (srv.env) serverConfig.env = srv.env;
        
        config.mcp.servers.push(serverConfig);
        write('forge.yaml', yaml.dump(config));
        
        log(`‚úÖ Added ${server} to forge.yaml`);
        if (srv.env) {
          log(`\n‚ö†Ô∏è  Set environment variables:`);
          Object.keys(srv.env).forEach(k => log(`   export ${k}=your_value`));
        }
      },
      
      suggest: () => {
        const config = exists('forge.yaml') ? yaml.load(fs.readFileSync('forge.yaml', 'utf8')) : {};
        const projectType = config.projectType || 'web';
        const suggested = mcpServers.projectTypes[projectType] || mcpServers.projectTypes.web;
        
        log(`üìã Suggested MCP servers for ${projectType} project:\n`);
        suggested.forEach(s => {
          const srv = mcpServers.servers[s];
          if (srv) log(`  ‚Ä¢ ${s}: ${srv.description}`);
        });
        log(`\nüí° Add all: forge mcp add ${suggested.join(' ')}`);
      }
    };
    
    (subcommands[action] || subcommands.list)();
  }
};

// Handle version flags
if (cmd === '--version' || cmd === '-v') {
  const pkg = JSON.parse(fs.readFileSync(path.join(__dirname, 'package.json'), 'utf8'));
  log(`forge v${pkg.version}`);
} else if (commands[cmd]) {
  commands[cmd](...args);
} else {
  log(`üî® FORGE Framework

Commands:
  init         Initialize FORGE
  new <name>   Start feature cycle  
  status       Show current cycle (--detailed for full view)
  phase        Manage cycle phases
  complete     Archive cycle (--force to skip validation)
  learn        View/manage learnings
  document     Start documentation
  mcp          Manage MCP servers
  uninstall    Remove FORGE

Phase: status | next | complete
Learn: retrospective | pattern | claude
MCP: list | suggest | add <server>`);
}